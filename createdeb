#!/usr/bin/env ruby

require 'optparse'
require 'tmpdir'
require 'logger'

require 'pp'

$log = Logger.new(STDOUT)
$log.level = Logger::DEBUG

module Createdeb; end

class Createdeb::DebDesc
	def initialize(filename)
		@filename = filename
		@fields = []

		parse!
	end

	def parse!
		in_field = false
		name = nil
		prev_lines = []

		lines = File.open(@filename).lines.to_a + ["\n"]
		lines.each_with_index do |line, idx|
			first = line[0..0]

			if first == '#'
				$log.debug "skipping comment line #{idx}"

				next
			end

			if [' ', "\t"].include?(first)
				if !in_field
					raise "Parsing error on line #{idx}"
				end

				$log.debug "continuing previous line for #{name.inspect} with #{line.inspect}"

				prev_lines << line
				next
			end

			if in_field
				$log.debug "completed field #{name.inspect}"
				@fields << Field.new(name, prev_lines)

				in_field = false
				name = nil
				prev_lines = []
			end

			if first == "\n"
				next
			end

			name, value = line.split(':', 2)
			prev_lines = []
			prev_lines << value
			in_field = true

			$log.debug "starting new field #{name.inspect}"
		end
	end

	def has_field(field_name)
		return @fields.any? { |f| f.name == field_name }
	end

	def fields(field_name)
		return @fields.select { |f| f.name == field_name }
	end

	def field(field_name)
		fields = fields(field_name)

		if fields.empty?
			return Field.new(field_name, nil)
		end

		# TODO: check unique

		return fields.first
	end

	class Field
		def initialize(name, lines)
			@name = name
			@lines = lines
		end

		attr_reader :name
		attr_reader :lines

		def simple_value
			if lines.nil?
				return nil
			end

			# FIXME: check

			return lines.first.strip
		end

		def pair_value
			value = simple_value

			if value.nil?
				return [nil, nil]
			end

			return value.split(' ')
		end

		def folded_value
			if lines.nil?
				return nil
			end

			return lines.map { |l| l.strip }.join(' ')
		end
	end
end

class Createdeb::CLI
	def initialize(params)
		@options = {}

		parse!(params)
	end

	def parse!(params)
		OptionParser.new do |opts|
			opts.banner = "Usage: createdeb [options] FILE"

			opts.on('-t', '--timestamp-version', "Add timestamp to the version number") do
				@options[:timestamp] = true # TODO: use
			end

			opts.on_tail('-h', '--help', "Display help text and usage") { puts opts; exit }

			opts.parse!
		end

		@input_file = ARGV.first
		@pkg = @input_file.sub('.debdesc', '')

		@orig_dir ||= @pkg
	end

	def setup!
		@debdesc = Createdeb::DebDesc.new(@input_file)

		@tmp_dir = Dir.mktmpdir('createdeb-')
		@work_dir = @tmp_dir + "/" + source_pkg(@debdesc) + '-' + version(@debdesc)
		FileUtils.mkdir_p(@work_dir)
	end

	def tear_down!
#		FileUtils.remove_entry_secure(@tmp_dir)
	end

	def copy_files!
		FileUtils.mkdir_p("#{@work_dir}/files")

		@to_copy = @debdesc.fields('Copy')
pp @to_copy
		@to_copy.each do |field|
			file, dest = field.pair_value
p dest
			# TODO: recreate directory structure, otherwise only one file with a certain name is allowed
			FileUtils.cp("#{@orig_dir}/files/#{file}", "#{@work_dir}/files/")
		end
	end

	def create_patches!
		@to_diff = @debdesc.fields('Diff')
pp @to_diff
		@to_diff.each do |field|
			file = field.simple_value
			diff_cmd = ["diff", "-u2", "#{@orig_dir}/diff/#{file}.orig", "#{@orig_dir}/diff/#{file}"]
			patch_path = "#{@work_dir}/patches/#{file}.diff"
			patch = ""
			IO.popen(diff_cmd.join(' ')) { |io| patch = io.read }

			patch.sub!("#{@pkg}/diff/", '').sub!("#{@pkg}/diff/", '')

			FileUtils.mkdir_p(File.dirname(patch_path))
			File.open(patch_path, "w") { |file| file << patch }
		end
	end

	def create_fixed_debian_files!
		deb_dir = @work_dir + '/debian'
		FileUtils.mkdir(deb_dir)

		FileUtils.mkdir(deb_dir + '/source')
		File.open(deb_dir + '/source' + '/format', 'w') { |f| f << "3.0 (native)\n" }

		File.open(deb_dir + '/compat', 'w') { |f| f << "9\n" }

		File.open(deb_dir + '/rules', 'w') do |f|
			f << "#!/usr/bin/make -f\n"
			f << "\n"
			f << "%:\n"
			f << "\tdh $@\n"

		end
		FileUtils.chmod(0o755, deb_dir + '/rules')
	end

	def create_maintscripts!
		# TODO: support for user-defined maintscript
		# TODO: pre-depend on patch

		maintscripts_dir = "#{@work_dir}/maintscripts"
		maintscripts_dir = "#{@work_dir}/debian"
		unless @to_diff.empty?
			FileUtils.mkdir_p(maintscripts_dir)

			File.open("#{maintscripts_dir}/postinst", "w") do |f|
				f << "#!/bin/sh\n"
				f << @to_diff.map { |d| "patch -p0 -i /usr/share/#{@pkg}/patches/#{d.simple_value}.diff\n" }
			end

			File.open("#{maintscripts_dir}/prerm", "w") do |f|
				f << "#!/bin/sh\n"
				f << @to_diff.map { |d| "patch -R -p0 -i /usr/share/#{@pkg}/patches/#{d.simple_value}.diff\n" }
			end
		end
	end

	def create_install_file!
		File.open("#{@work_dir}/debian/install", "w") do |f|
			f << @to_copy.map { |c| val = c.pair_value; "files/#{val.first} #{val.last}\n" }
			f << @to_diff.map { |d| patch = "#{d.simple_value}.diff" ; "patches/#{patch} /usr/share/#{@pkg}/patches/#{File.dirname(patch)}\n" }
		end
	end

	def create_changelog!
		ver = version(@debdesc)
		maint = maintainer(@debdesc)

		# TODO: create proper changelog
		File.open("#{@work_dir}/debian/changelog", "w") do |f|

			f << "#{@pkg} (#{ver}) unstable; urgency=low\n"
			f << "\n"
			f << "  * Generated by createdeb\n"
			f << "\n"
			f << " -- #{maint}  #{`date -R`}\n"
		end
	end

	def create_control!
		maint = maintainer(@debdesc)

		File.open("#{@work_dir}/debian/control", "w") do |f|
			f << "Source: #{@pkg}\n"
			f << "Section: misc\n"
			f << "Priority: optional\n"
			f << "Build-Depends: debhelper (>=7)\n"
			f << "Maintainer: #{maint}\n"
			f << "Standards-Version: 3.9.2\n"

			f << "\n"

			f << "Package: #{@pkg}\n"
			f << "Architecture: all\n"
			f << "Pre-Depends: patch\n" unless @to_diff.empty?
			f << "Depends: #{@debdesc.field('Depends').folded_value}\n"
			f << "Description: fake\n"
		end
	end

	def build_package!
		Dir.chdir(@work_dir) do
			build_cmd = ['dpkg-buildpackage', '-rfakeroot']
			IO.popen(build_cmd.join(' ')) do |io| puts io.read end
		end

#		if !$?.success? then raise("Error during build") end
		p $?
	end

	def move_package!
		deb_name = "#{@pkg}_#{version(@debdesc)}_all.deb"
		FileUtils.cp("#{@tmp_dir}/#{deb_name}", Dir.pwd)
	end

	def run!
		begin
			setup!

			copy_files!
			create_patches!

			create_fixed_debian_files!

			create_maintscripts!
			create_install_file!
			create_changelog!
			create_control!

			build_package!
			move_package!
		ensure
			tear_down!
		end
	end

	def source_pkg(desc)
		return @pkg
	end

	def version(desc)
		v = desc.field('Version').simple_value || '1.0'
		return v
	end

	def maintainer(desc)
		return desc.field('Maintainer').simple_value
	end
end

app = Createdeb::CLI.new(ARGV)
app.run!


