#!/usr/bin/env ruby

require 'tmpdir'
require 'logger'

require 'pp'

$log = Logger.new(STDOUT)
$log.level = Logger::DEBUG

module Createdeb; end

class Createdeb::DebDesc
	def initialize(filename)
		@filename = filename
		@fields = []

		parse!
	end

	def fields(field_name)
		return @fields.select { |f| f[:name] == field_name }
	end

	def parse!
		in_field = false
		name = nil
		prev_lines = []

		lines = File.open(@filename).lines.to_a + ["\n"]
		lines.each_with_index do |line, idx|
			first = line[0..0]

			if first == '#'
				$log.debug "skipping comment line #{idx}"

				next
			end

			if [' ', "\t"].include?(first)
				if !in_field
					raise "Parsing error on line #{idx}"
				end

				$log.debug "continuing previous line for #{name.inspect} with #{line.inspect}"

				prev_lines << line
				next
			end

			if in_field
				$log.debug "completed field #{name.inspect}"
				@fields << { :name => name, :value => prev_lines }

				in_field = false
				name = nil
				prev_lines = []
			end

			if first == "\n"
				next
			end

			name, value = line.split(':', 2)
			prev_lines = []
			prev_lines << value
			in_field = true

			$log.debug "starting new field #{name.inspect}"
		end
	end
end

class Createdeb::CLI
	def initialize(params)
		parse!(params)
	end

	def parse!(params)
		# TODO: use parser
		@input_file = params[0]
		@pkg = params[0].sub('.debdesc', '')
		@orig_dir = @pkg

		# TODO --add-timestamp-version, -t
	end

	def setup!
		@debdesc = Createdeb::DebDesc.new(@input_file)

		@tmp_dir = Dir.mktmpdir('createdeb-')
		@work_dir = @tmp_dir + "/" + source_pkg(@debdesc) + '-' + version(@debdesc)
		FileUtils.mkdir_p(@work_dir)
	end

	def tear_down!
#		FileUtils.remove_entry_secure(@tmp_dir)
	end

	def copy_template!
		FileUtils.cp_r("/usr/share/equivs/template/debian", @work_dir)
	end

	def copy_files!
		FileUtils.mkdir_p("#{@work_dir}/files")

		@to_copy = @debdesc.fields('Copy')
pp @to_copy
		@to_copy.each do |field|
			file, dest = field[:value].first.strip.split(' ')
p dest
			# TODO: recreate directory structure, otherwise only one file with a certain name is allowed
			FileUtils.cp("#{@orig_dir}/files/#{file}", "#{@work_dir}/files/")
		end
	end

	def create_patches!
		@to_diff = @debdesc.fields('Diff')
pp @to_diff
		@to_diff.each do |field|
			file = field[:value].first.strip
			diff_cmd = ["diff", "-u2", "#{@orig_dir}/diff/#{file}.orig", "#{@orig_dir}/diff/#{file}"]
			patch_path = "#{@work_dir}/patches/#{file}.diff"
			patch = ""
			IO.popen(diff_cmd.join(' ')) { |io| patch = io.read }

			patch.sub!("#{@pkg}/diff/", '').sub!("#{@pkg}/diff/", '')

			FileUtils.mkdir_p(File.dirname(patch_path))
			File.open(patch_path, "w") { |file| file << patch }
		end
	end

	def create_maintscripts!
		# TODO: support for user-defined maintscript
		# TODO: pre-depend on patch

		maintscripts_dir = "#{@work_dir}/maintscripts"
		maintscripts_dir = "#{@work_dir}/debian"
		unless @to_diff.empty?
			FileUtils.mkdir_p(maintscripts_dir)

			File.open("#{maintscripts_dir}/postinst", "w") do |f|
				f << "#!/bin/sh\n"
				f << @to_diff.map { |d| "patch -p0 -i /usr/share/#{@pkg}/patches/#{d[:value].first.strip}.diff\n" }
			end

			File.open("#{maintscripts_dir}/prerm", "w") do |f|
				f << "#!/bin/sh\n"
				f << @to_diff.map { |d| "patch -R -p0 -i /usr/share/#{@pkg}/patches/#{d[:value].first.strip}.diff\n" }
			end
		end
	end

	def create_install_file!
		File.open("#{@work_dir}/debian/install", "w") do |f|
			f << @to_copy.map { |c| val = c[:value].first.strip.split(' '); "files/#{val.first} #{val.last}\n" }
			f << @to_diff.map { |d| patch = "#{d[:value].first.strip}.diff" ; "patches/#{patch} /usr/share/#{@pkg}/patches/#{File.dirname(patch)}\n" }
		end
	end

	def create_changelog!
		ver = version(@debdesc)
		maint = maintainer(@debdesc)

		# TODO: create proper changelog
		File.open("#{@work_dir}/debian/changelog", "w") do |f|

			f << "#{@pkg} (#{ver}) unstable; urgency=low\n"
			f << "\n"
			f << "  * Generated by createdeb\n"
			f << "\n"
			f << " -- #{maint}  #{`date -R`}\n"
		end
	end

	def create_control!
		maint = maintainer(@debdesc)

		File.open("#{@work_dir}/debian/control", "w") do |f|
			f << "Source: #{@pkg}\n"
			f << "Section: misc\n"
			f << "Priority: optional\n"
			f << "Build-Depends: debhelper (>=7)\n"
			f << "Maintainer: #{maint}\n"
			f << "Standards-Version: 3.9.2\n"

			f << "\n"

			f << "Package: #{@pkg}\n"
			f << "Architecture: all\n"
			f << "Pre-Depends: patch\n" unless @to_diff.empty?
			f << "Depends: " << @debdesc.fields('Depends').first[:value]
			f << "Description: fake\n"
		end
	end

	def build_package!
		Dir.chdir(@work_dir) do
			build_cmd = ['dpkg-buildpackage', '-rfakeroot']
			IO.popen(build_cmd.join(' ')) do |io| puts io.read end
		end

#		if !$?.success? then raise("Error during build") end
		p $?
	end

	def move_package!
		deb_name = "#{@pkg}_#{version(@debdesc)}_all.deb"
		FileUtils.cp("#{@tmp_dir}/#{deb_name}", Dir.pwd)
	end

	def run!
		begin
			setup!

			copy_template! # FIXME: remove
			copy_files!
			create_patches!

			create_maintscripts!
			create_install_file!
			create_changelog!
			create_control!

			build_package!
			move_package!
		ensure
			tear_down!
		end
	end

	def source_pkg(desc)
		return @pkg
	end

	def version(desc)
		v = desc.fields('Version').first || { :value => '1.0' }
		return v[:value].first.strip
	end

	def maintainer(desc)
		return desc.fields('Maintainer').first[:value].first.strip
	end
end

app = Createdeb::CLI.new(ARGV)
app.run!


